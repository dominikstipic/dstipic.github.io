<!doctype html>
<head>
  <title>Dominik Stipić</title>
  <link rel="icon" href="favicon.ico" />
  <link rel="stylesheet" type="text/css" href="../../css/style.css">
</head>
<body>

<h1>Different views on the function</h1>

    In programming language courses and education, the function is viewed as the
block of code that unifies some repeating behaviour. Beginner programmers will
write the code in one block. He will then notice that he is repeating himself
and then he will extract the repeating code to the new function and reduce the
number of letters in his original code. I call this operation <textbf>unify</textbf>.

<br>
<br>
<br>

<img src="../../figs/unify (1).png " alt="A beautiful mountain landscape" width="600" height="300" style="display: block; margin: 0 auto;"></img>
<p style="font-size: 0.9em; color: #666; text-align: center;">Simple unify operation. Creation of shared memory and pointing to the shared memory. Syntax complexity is decreased. </p>

<br>
<br>
<br>

The operation involves slicing the document into repeating patterns and then unifying
this into one shared memory, which could then be repeatedly called or referred
to. This view of function writing could be called unification. 
<br>
In the next step, we have a type of code which is only slightly different from each other, slices
of code are in the same functionality set and they need to be adapted in one
common semantic representation which is then shared. Here we are not only reducing the syntax complexity. 

<br>
<br>
<br>

<img src="../../figs/abs.png" width="600" height="300" style="display: block; margin: 0 auto;"></img>
<p style="font-size: 0.9em; color: #666; text-align: center;">Abstractioning away differences and unifying </p>

<br>
<br>
<br>



Another motivation for writing function is to label and simplify very complex behaviour so that it is easier to read and work with. We are decluttering 
the visual space to be more productive and better understand our work. This approach is called naming approach. We could also argue that this is some
extension of spatial logic. If someone mentioned the primitive man word see he would be able to extend this word to creatures or things with whom he had
direct contact or connection. This type of logic could be described as graph
logic on the type of connection which one knows.

<br>
<br>
<br>

<img src="../../figs/pal.png" width="500" height="300" style="display: block; margin: 0 auto;"></img>
<p style="font-size: 0.9em; color: #666; text-align: center;"> Paleolitic group and group thought expansion using shared propositional logic</p>

<br>
<br>
<br>


Next, we have the temporal logic or the logic which is directed toward predicting what will happen in the future. If the hunter-gatherer sees the animal in the open and observes that there is no enough food or grass with whom
he could feed himself or the heard he predicts that in the next season, the animal will leave the place.  
Temporal logic with uncertainty has a probability element or implementation of uncertainty. In formal theory, the temporal logic is expanding the common propositional 
logic symbols such as ¬ , ∨ , ∧ , → with the:
<ul>
  <li>Fp = eventually p</li>
  <li>GP = G is always valud</li>
  <li>Xp = next step p is valid</li>
  <li>pUq = p unit q</li>
</ul> 
In fact, temporal linear logic is probably the foundation behind the decision theory. 

<br>
<br>
<br>

<img src="../../figs/graph.png" width="600" height="300" style="display: block; margin: 0 auto;"></img>
<p style="font-size: 0.9em; color: #666; text-align: center;"> Mapping propositional logic on colored graph, each individual possess his own propositional graph based on experience and knowledge</p>


<h1>Conclusion</h1>
In conclusion, this short article wanted to demonstrate how programming function could have different views and motivations behind its implementation. 
We differentiate between structural 


</body>